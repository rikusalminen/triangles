#version 330

layout(triangles_adjacency) in;
layout(triangle_strip, max_vertices = 15) out;

uniform mat4 projection_matrix;
uniform mat4 shadow_matrix;
uniform mat4 view_matrix;

uniform vec4 light_position;

in struct camera_space_ {
    vec4 position;
} camera_space[];

out vec4 color;

void main()
{
    vec4 light = view_matrix * light_position;

    vec4 a = camera_space[0].position;
    vec4 b = camera_space[2].position;
    vec4 c = camera_space[4].position;

    vec3 normal = normalize(cross((b-a).xyz, (c-a).xyz));
    vec4 plane = vec4(normal.xyz, -dot(normal, a.xyz));
    float dist = dot(light, plane);

    if(dist > 0) {
        // front face
        color = vec4(1.0, 1.0, 1.0, 1.0);
        gl_Position = projection_matrix * a;
        EmitVertex();

        color = vec4(1.0, 1.0, 1.0, 1.0);
        gl_Position = projection_matrix * b;
        EmitVertex();

        color = vec4(1.0, 1.0, 1.0, 1.0);
        gl_Position = projection_matrix * c;
        EmitVertex();

        EndPrimitive();
    } else {
        // back face
        color = vec4(1.0, 1.0, 1.0, 1.0);
        vec4 light_a = normalize(light - a);
        gl_Position = projection_matrix * (a - 5*light_a);
        EmitVertex();

        color = vec4(1.0, 1.0, 1.0, 1.0);
        vec4 light_b = normalize(light - b);
        gl_Position = projection_matrix * (b - 5*light_b);
        EmitVertex();

        color = vec4(1.0, 1.0, 1.0, 1.0);
        vec4 light_c = normalize(light - c);
        gl_Position = projection_matrix * (c - 5*light_c);
        EmitVertex();

        EndPrimitive();
    }

    for(int i = 0; i < 3; ++i) {
        vec4 vert = camera_space[2*i].position;
        vec4 next = camera_space[(2*i+2)%6].position;
        vec4 adj = camera_space[2*i+1].position;

        vec3 normal_adj = normalize(cross((adj-vert).xyz, (next-vert).xyz));
        vec4 plane_adj = vec4(normal_adj.xyz, -dot(normal_adj, vert.xyz));
        float dist_adj = dot(light, plane_adj);

        if(dist > 0 && dist_adj < 0) {
            vec4 light_next = normalize(light - next);
            vec4 light_vert = normalize(light - vert);

            // Silhouette edge detected
            color = vec4(1.0, 1.0, 1.0, 1.0);
            gl_Position = projection_matrix * next;
            EmitVertex();

            color = vec4(1.0, 1.0, 1.0, 1.0);
            gl_Position = projection_matrix * vert;
            EmitVertex();

            color = vec4(1.0, 1.0, 1.0, 1.0);
            gl_Position = projection_matrix * (next - 5*light_next);
            EmitVertex();

            color = vec4(1.0, 1.0, 1.0, 1.0);
            gl_Position = projection_matrix * (vert - 5*light_vert);
            EmitVertex();

            EndPrimitive();
        }
    }
}
